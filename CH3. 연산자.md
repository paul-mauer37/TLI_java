# CH3. 연산자

**연산**이란 데이터를 처리하여 결과를 산출하는 것. 이때 사용되는 표시나 기호를 **연산자**, 데이터를 **피연산자**라고 하며 연산의 과정을 기술한 것을 **연산식**이라 한다.



### 1. 부호 연산자 : `+` , `-`

부호 연산자는 부호를 연산하는(곱하는) 것과 같기 때문에 부호 연산자의 기본적인 산출 타입은 **int**타입이 된다. 이때 저장 크기가 작은 타입은 저장 크기가 큰 타입의 데이터 타입을 따라가게 된다.

```java
short s = -100;
// short result3 = -s;		// 컴파일 에러 : -s는 부호 연산에 의해 int타입이 되기 때문
int result3 = -s;

long y = 500;
// int result4 = -y;		// 컴파일 에러 : long타입이 int타입보다 저장 크기가 크기 때문
long result4 = -y;
```



### 2. 증감 연산자 : `++` , `--`

피연산자의 값을 **1 증가** 또는 **1 감소**

유의할 점은, **변수보다 증감연산자(`++`/`--`)가 뒤에 있을 경우** 다른 연산을 수행한 후에 증감 연산이 이루어짐.

```java
int x = 1;
int result1 = ++x + 10;
// result1 = 12		// result1연산보다 증감 연산이 먼저 이루어짐
int y = 1;
int result2 = y++ + 10;
// result2 = 11		// result2연산보다 증감 연산이 나중에 이루어짐
```



### 3. 논리 부정 연산자 : `!`

**boolean타입에서만** 사용되며 `true`를 `false`로, `false`를 `true`로 변경한다.

```java
boolean play = true;
// play = true
play = !play;
// play = false
play = !play;
// play = true
```



### 4. 비트 반전 연산자 : `~`

0과 1의 비트값을 반전한다.

> cf.
>
> Integer.toBinaryString() 메소드
>
> toBinaryString(변수)



### 5. 산술 연산자 : `+` , `-` , `*` , `/` , `%`

사칙연산과 관련한 연산자

* 산술 연산자 규칙

  * 피연산자가 모두 **정수** 타입이고, **int타입(4)보다 크기가 작은** 타입일 경우 **=>** 산출 타입은 **int**이다.

  * 크기가 작은 타입은 크기가 큰 타입을 따라간다. 실수 타입도 마찬가지다.

  * 정수 타입의 사칙연산에서 **실수** 타입의 정확한 값을 산출하려면, 피연산자 중 **최소한 하나는 실수** 타입이어야 한다.

    ```java
    int int1 = 10;
    int int2 = 4;
    double result3 = int1 / int2;
    // result3 = 2.0		// 사칙연산은 int를 기준으로 발생하였으므로 int1/int2의 값인 2가 실수형인 2.0으로 표현되었을 뿐이다.
    double result4 = (int1*1.0) / int2;
    double result5 = (double) int1 / int2;
    // result4 = result5 = 2.5		// 연산 내부에 실수형이 존재해야 하므로 피연산자에 1.0을 곱해주거나, 피연산자를 캐스팅해주면 된다.
    ```

    

> 자바는 리터럴 간의 연산은 타입 변환 없이 해당 타입으로 계산한다. (리터럴은 하나의 수 혹은 값에 지나지 않기 때문)



>cf.
>
>* 오버플로우(산출 타입으로 표현할 수 없는 값) => 오버플로우 탐지 메소드(`safeAdd()`), 예외처리(`catch(ArithmeticException e) { }`)
>
>* float, double은 0.1을 정확히 표현할 수 없으며, 정수 연산으로 변경하여 정확하게 계산할 수 있다.
>* `변수타입.isInfinite(변수)` : 변수가 Infinite인지 판별
>* `변수타입.isNaN(변수)` : 변수가 NaN인지 판별
>* `변수타입.valueOf(변수)` : 변수를 변수타입으로 변환



### 6. 문자열 연결 연산자 : `+`

문자열을 서로 결합하는 연산자

* 연산 순서에 따라 결과가 달라질 수 있다

  ```java
  "JDK" + 3 + 3.0;
  // 결과값 : "JDK33.0"		// 문자열 + 문자열 = 문자열
  3 + 3.0 + "JDK";
  // 결과값 : "6.0JDK"		// 수 + 문자열 = 문자열
  ```



### 7. 비교 연산자 : `<` , `<=` , `>` , `>=` , `==` , `!=`

동등비교(같은지 다른지) 혹은 크기비교(큰지 작은지)

* 참조 타입인 String변수를 비교할 때, `==`연산자는 오류가 생길 수 있다 => `equals()`메소드 사용

  ```java
  String strVar1 = "신용권";
  String strVar2 = "신용권";
  String strVar3 = new String("신용권");    
  // 자바는 문자열 리터럴이 동일하다면 동일한 String 객체를 참조한다. 변수 strVar1과 strVar2는 동일한 String 객체의 번지값을 갖는다.
  // 반면 변수 strVar3은 새로운 String 객체의 번지값을 갖는다.(객체 생성 연산자 new 때문)
  System.out.println(strVar1 == strVar2);		// true
  System.out.println(strVar1 == strVar3);		// false
  // equals()메소드 사용
  System.out.println(strVar1.equals(strVar2));		// true
  System.out.println(strVar1.equals(strVar3));		// true
  ```

  

### 8. 논리 연산자 : `&&` , `&`, `||` , `|` , `^` , `!`

* AND : 모두 true  =>  `&&`, `&`
  * `&&`은 앞의 것이 false면 뒤의 것은 평가하지 않고 false 산출 (효율적)
* OR : 하나라도 true  =>  `||`, `|`
  * `||`은 앞의 것이 true면 뒤의 것은 평가하지 않고 true 산출 (효율적)
* XOR : 둘 중 하나만 true  =>  `^`
* NOT : 논리값 반전  =>  `!`



### 9. 비트 연산자

비트 단위 2진수 계산, 조정 연산자

* 비트 논리 연산자 : `&` , `|` , `^` , `~`
* 비트 이동 연산자 : `<<` , `>>` , `>>>`



### 10. 대입 연산자 : `+=` , `-=` , `*=` , `/=` , `%=` , `&=` , `|=` , `^=` , `<<=` , `>>=` , `>>>=`

>형태 : 변수 [대입연산자] 피연산자

기존 변수값에 피연산자를 연산하고, 도출된 값을 새로운 변수값으로 저장

```java
int result = 0;		// 0
result += 10;		// 10
result -= 5;		// 5
result *= 3;		// 15
result /= 5;		// 3
result %= 3;		// 0
```



### 11. 삼항 연산자

조건식의 결과에 따라 : (콜론) 앞뒤의 피연산자가 선택된다

> 형태 : 조건식 ? 값1 : 값2

```java
int score = 95;
char grade = (score>90) ? 'A' : 'B';
// 삼항 연산자를 이용한 위 표현식은 아래 if문을 이용한 표현식과 같다.
char grade;
if(score>90)	{
    grade = 'A';
} else	{
    grade = 'B';
}
```



